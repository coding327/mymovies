[toc]
## 微信小程序项目实战具体流程

## 创建项目
1. 项目名称要和存放项目目录名称一致，如项目名称myapp，目录名称也应为myapp
2. AppID，这个自己提前准备好
3. 开发模式选择小程序
4. 后端服务不使用云服务
5. 语言javascript

## 项目初始化【清0操作】
1. 找到app.js，只保留如下代码【把配置项置空===空对象】
```js
// app.js
App({
})
```

2. 进入app.wxss，里面代码全部清除

3. 删除utils整个目录

4. 删除pagindex/index目录
    - 对应app.json文件里的pages下的 index/index/logs"`也要删除

> 下面这步可以选择把index整个目录都删除掉，也可以像下面这样一个一个清除
### 以简单方案为主：
1. 删除pages目录下的整个index目录
    - 对应app.json文件里的pages下的 `"pages/index/index"`也要删除

### 不嫌麻烦可以按照如下方法清除index目录下的文件
1. 进入pages/index/index.js文件中，只保留如下代码【把配置项置空===空对象】
```js
// index.js
// 获取应用实例
const app = getApp()

Page({
})
```

2. 进入pages/index/index.wxml文件中，清除全部结构代码

3. 进入pages/index/index.wxss文件中，清除全部样式代码

## 静态资源准备
1. 项目所需图片及图标imgs直接放到项目根目录下即可

## tab栏先做出来

1. 新建home页面，在pages目录下新建文件夹名称自己定一般为`home`即首页
    - 接着在home目录下右键选择新建Page，也为home

2. 新建about页面，在pages目录下新建文件夹名称为`about`
    - 接着在about目录下右键选择新建Page，也为about

3. 配置页面，进入app.json文件中，找到pages配置如下【目前只要新建页面都会自动帮我们配好，如果没配我们就自己手动配置，但是删除页面不会自动帮我们清除】
```json
    "pages": [
        "pages/home/home",
        "pages/about/about"
    ],
```

4. 依旧是在app.json文件中，window配置项后面换行输入tab会有提示tabBar,回车即可，记得最后面加上逗号
参数解读：
pagePath：页面路径【不要以/开头，直接从pages目录下写即可】
text：页面的名称【图标下方文本】
iconPath：图标路径【默认不选中的图标】
selectedIconPath：图标路径【选中以后的图标】
完整代码如下：
```json
    "tabBar": {
      "list": [
        {
          "pagePath": "pages/home/home",
          "text": "首页",
          "iconPath": "/imgs/film-close.png",
          "selectedIconPath": "/imgs/film-open.png"
        },
        {
          "pagePath": "pages/about/about",
          "text": "关于",
          "iconPath": "/imgs/me-close.png",
          "selectedIconPath": "/imgs/me-open.png"
        }
      ]
    },
```

## 修改顶部导航栏相关样式，在app.json文件中，有如下代码：
```json
    "window": {
        "backgroundTextStyle": "light",
        "navigationBarBackgroundColor": "#fff",
        "navigationBarTitleText": "Weixin",
        "navigationBarTextStyle": "black"
    },
```
代码解读：
backgroundTextStyle：窗口背景色，这个一般不需要动
navigationBarBackgroundColor：导航栏背景颜色
navigationBarTitleText：导航栏文本
navigationBarTextStyle：导航栏文本颜色

修改后：
```json
    "window": {
        "backgroundTextStyle": "light",
        "navigationBarBackgroundColor": "#42bd56",
        "navigationBarTitleText": "movie",
        "navigationBarTextStyle": "white"
    },
```

## 首页绘制
1. 清除pages/home/home.wxml中的代码
2. 根据设计图绘制页面（可以发现整个背景都是灰色，给容器即page添加灰色背景）
进入app.wxss给page添加灰色即可
```css
page {
    background-color: #efefef;
}
```
在我们微信小程序里面不是view就是text然后就是组件
进入home.wxml书写我们页面结构
```html
<view class="film">
    <view class="film-type">
        <!-- 分类标题 start -->
        <view class="type-title">
            <text>影院热映</text>
            <navigator>更多 ></navigator>
        </view>
        <!-- 分类标题 end -->
        <!-- 电影列表 start -->
        <view class="film-list">
            <view class="film-item" wx:for="{{ 6 }}" wx:key="index">
                <image class="film-img" src="/imgs/film.jpg"></image>
                <view class="film-name">美丽人生</view>
                <view class="film-star">
                    <image class="star-img" src="/imgs/star-open.png" wx:for="{{ 5 }}" wx:key="index"></image>
                    <text class="film-source">9.5</text>
                </view>
            </view>
        </view>
        <!-- 电影列表 end -->
    </view>
</view>
```

进入home.wxss书写样式[这里只写部分影院热映样式，具体看项目里的home.wxss]
单位1rpx=0.5px=1物理像素
```css
/* pages/home/home.wxss */

.film {
    width: 100%;
}

.film-type {
    background-color: white;
    margin-bottom: 20rpx;
}

/* 分类标题 */
.type-title {
    padding: 26rpx 0;
    font-size: 28rpx;
    font-weight: bold;
    color: #333;
}
.type-title text{
    border-left: 6rpx solid #42bd56;
    padding-left: 26rpx;
}
.type-title navigator {
    float: right;
    color: #42bd56;
    padding-right: 16rpx;
}

/* 电影列表 */
.film-list {
    width: 100%;
    white-space: nowrap;
}
.film-item {
    display: inline-block;
    width: 200rpx;
    padding: 0 12rpx;
}
.film-img {
    width: 100%;
    height: 280rpx;
}
.film-name {
    font-size: 22rpx;
    font-weight: bold;
    color: #333;
    /* 对于较长的电影名称进行处理 */
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
.film-star {
    width: 100%;
}
.film-star .star-img {
    width: 20rpx;
    height: 20rpx;
}
.film-star .film-source {
    font-size: 20rpx;
    color: #999;
    padding-left: 8rpx;
}
```

### 横向滚动实现
> 可以使用微信小程序里提供的scroll-view组件，并指定scroll-x横向滚动

```html
        <!-- 电影列表 start -->
        <!-- 替换横向滚动组件，并指定scroll-x -->
        <scroll-view class="film-list" scroll-x>
            <view class="film-item" wx:for="{{ 6 }}" wx:key="index">
                <image class="film-img" src="/imgs/film.jpg"></image>
                <view class="film-name">美丽人生</view>
                <view class="film-star">
                    <image class="star-img" src="/imgs/star-open.png" wx:for="{{ 5 }}" wx:key="index"></image>
                    <text class="film-source">9.5</text>
                </view>
            </view>
        </scroll-view>
        <!-- 电影列表 end -->
```

### 接着把类别循环下即可，这样基于三个了
```html
<view class="film">
<!-- 类别有三个，循环三次即可 -->
    <view class="film-type" wx:for="{{ 3 }}" wx:key="index">
        <!-- 分类标题 start -->
        <view class="type-title">
            <text>影院热映</text>
            <navigator>更多 ></navigator>
        </view>
        <!-- 分类标题 end -->
        <!-- 电影列表 start -->
        <!-- 替换横向滚动组件，并指定scroll-x -->
        <scroll-view class="film-list" scroll-x>
            <view class="film-item" wx:for="{{ 6 }}" wx:key="index">
                <image class="film-img" src="/imgs/film.jpg"></image>
                <view class="film-name">美丽人生</view>
                <view class="film-star">
                    <image class="star-img" src="/imgs/star-open.png" wx:for="{{ 5 }}" wx:key="index"></image>
                    <text class="film-source">9.5</text>
                </view>
            </view>
        </scroll-view>
        <!-- 电影列表 end -->
    </view>
</view>
```

## 绘制分类页
> 在pages目录下创建一个文件夹叫list，再新建个Page也叫list
为了方便观察页面，我们可以去app.json文件里有个pages，把list路径提到最前面
```json
    "pages": [
        "pages/list/list",
        "pages/home/home",
        "pages/about/about"
    ],
```

进入list.wxml书写分类页结构，发现每一项电影和之前首页一样抽离成组件

### 组件抽离
在项目根目录创建一个components文件夹用来放复用组件，在components目录下再新建一个文件夹名称为film-item对应该组件功能，方便管理，接着鼠标右键新建Component名称也是film-item，把首页可以抽离代码剪切拿过来，注意把循环去掉，在使用时循环组件即可
```html
<!--components/film-item/film-item.wxml-->
<view>
    <image class="film-img" src="/imgs/film.jpg"></image>
    <view class="film-name">美丽人生</view>
    <view class="film-star">
        <image class="star-img" src="/imgs/star-open.png" wx:for="{{ 5 }}" wx:key="index"></image>
        <text class="film-source">9.5</text>
    </view>
</view>
```

### 组件样式
样式也需要拿过来，最外面item这一层样式不拿过来[最外层view最好不加样式]，使用时我们自己去调更适合于不同页面
```css
/* components/film-item/film-item.wxss */
.film-img {
    width: 100%;
    height: 280rpx;
}
.film-name {
    font-size: 22rpx;
    font-weight: bold;
    color: #333;
    /* 对于较长的电影名称进行处理 */
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
.film-star {
    width: 100%;
}
.film-star .star-img {
    width: 20rpx;
    height: 20rpx;
}
.film-star .film-source {
    font-size: 20rpx;
    color: #999;
    padding-left: 8rpx;
}
```

### 组件注册
项目中多个页面都会使用到该组件把它做一个全局引用（全局注册）
进入app.json，在组后面接着添加属性usingComponents，组件名称我们也叫film-item，配组件路径以/起始
```json
    "usingComponents": {
        "film-item": "/components/film-item/film-item"
    }
```

### 组件调用
进入home.wxml，传入样式[下面是基本组件调用]
```html
<组件名称 class="class1"></组件名称>
```

具体代码：
```html
    <!-- 组件调用 -->
    <film-item class="film-item" wx:for="{{ 6 }}" wx:key="index"></film-item>
```

回到app.json把pages中的首页提前看一下页面是否可以
基本上是可以的，首页没什么问题，再到app.json里把分类页切换回来

### 分类页中调用组件
```html
    <film-item class="film-item" wx:for="{{ 12 }}" wx:key="index"></film-item>
```

### 书写样式
```css
/* pages/list/list.wxss */
.list {
    width: 100%;
}

.list-type {
    background-color: white;
    margin-bottom: 20rpx;
}

/* 分类标题 */
.type-title {
    padding: 26rpx 0;
    font-size: 28rpx;
    color: #333;
    font-weight: bold;
}
.type-title text {
    border-left: 6rpx solid #42bd56;
    padding-left: 26rpx;
}

/* 电影列表 */
.film-list {
    width: 100%;
    padding: 0 12rpx;
    box-sizing: border-box;
}
.film-item {
    display: inline-block;
    width: 33.33%;
    padding: 0 12rpx;
    box-sizing: border-box;
}
```

note: 首页和分类页共用`film-item`组件，但是它们的样式是不一样的，所以在封装组件时不要把样式固定死了，调用时根据不同页面去加样式

## 首页数据对接
`app.json`里的`pages`的`home`提到最上面，默认显示`home`页面
### 导航功能完善，点击更多跳转分类页
添加`url`指定路径即可
```html
<navigator url="/pages/list/list">更多 ></navigator>
```

### 数据如何对接，具体操作

1. 首页一加载，发请求获取数据渲染，在`home.js`文件里操作
这个在哪里做，其实在`onLoad`和`onReady`都可以，`onLoad`有个`options`一般传递参数用
我们选择在`onReady`中做请求数据

2. 请求都直接写在`onReady`中会很乱，于是三个不同分类最好封装成不同方法，在`onReady`中调用即可

> 这里我们接口是需要做合法域名配置的
### 后端接口合法域名配置
- 首先去微信小程序直接百度搜索点击小程序登录进去，找到开发管理，横排第三个吧有个开发设置，找到服务器域名咱们把接口上的域名填上去即可
- 回到编辑器右上角有个详情点击进去，再点击项目配置，刷新几次，直到域名信息`request`合法域名出现刚刚咱们配置的域名即可
- 如果你不配也可以在详情本地设置里面找到不校验合法域名、`web-view`(业务域名)。。。打上勾，这样也可以

做完上面这些，就可以书写请求接口，然后调接口了
```js
    data: {
        // 一个分类对应一个对象
        // type: {
        //     title: '',
        //     list: []
        // }
        // 既然分类有多个，那直接用数组即可
        types: [] // 存储所有的分类
    },

    onReady: function () {
        this.loadHotFilms()
    },
    loadHotFilms() {
        wx.request({
          url: 'https://m.douban.com/rexxar/api/v2/subject_collection/movie_showing/items',
          data: {
              start: 0,
              count: 6
          },
          success: res => {
            //   console.log(res)
            // 每一个分类作为一个对象
            let type = {
                title: res.data.subject_collection.name,
                list: res.data.subject_collection_items
            }
            // 注意是个对象里面再数组，不好用push
            this.setData({
                'types[0]': type
            })
          }
        })
    },
```

我们可以在控制台`AppData`中查看数据
### 这里注意一个问题this指向
> success要用箭头函数，不能使用匿名函数，不然拿不到数据，主要是this指向问题，因为箭头函数没有自己this，它依赖于父作用域中的this，而父作用域的this就是当前页面实例，这样就可以修改数据，这个实例才有data以及其中的types

### 数据展示
> 把原先得数据换成请求到得数据
公共组件film-item需要传递数据，父组件往子组件传递数据，进入film-item.js文件里，找到properties

```js
    properties: {
        film: {
            type: Object,
            value: {}
        }
    },
```

film-item.js
```js
<view>
    <!-- 使用传递过来数据 -->
    <image class="film-img" src="{{ film.cover.url }}"></image>
    <view class="film-name">{{ film.title }}</view>
    <view class="film-star">
    <!-- 星级评分展示处理，十分制，8<8.2图片亮的给4个 -->
        <image class="star-img" src="{{ (index+1)*2 <= film.rating.value ? '/imgs/star-open.png' : '/imgs/star-close.png' }}" wx:for="{{ 5 }}" wx:key="index"></image>
        <text class="film-source">{{ film.rating.value }}</text>
    </view>
</view>
```

> 上面三目运算比较长，使用wxs处理一下
在项目根目录下按照utils/tools.wxs这个层级创建文件夹和文件

```js
// 定义一个函数对评分进行处理

// 参数1星星的序号
// 参数2评分
function starImg(index, source) {
    return (index+1)*2 <= source ? '/imgs/star-open.png' : '/imgs/star-close.png'
}

// 函数导出
module.exports = {
    // 注意这里不能简写
    starImg: starImg
}
```

导入到film-item.wxml文件里，使用wxs标签
写在最下面写即可
```html
<!-- 模块名叫tools，随便取 -->
<wxs src="../../utils/tools.wxs" module="tools"></wxs>
```

调用方法
```html
 <!-- 星级评分展示处理，十分制，8<8.2图片亮的给4个 -->
        <image class="star-img" src="{{ tools.starImg(index,film.rating.value) }}" wx:for="{{ 5 }}" wx:key="index"></image>
        <text class="film-source">{{ film.rating.value }}</text>
```

### API请求的模块化处理
> 优化：将所有向后台api发送请求都放在一个api文件夹中，方便管理
项目根目录新建一个文件夹为api再创建api.js文件
```js
/**
 * API请求的模块化处理
 * 将项目中的所有请求都进行统一的管理
 * */ 

// 统一定义接口地址
const URLS = {
    hotUrl: 'https://m.douban.com/rexxar/api/v2/subject_collection/movie_showing/items',
    latestUrl: 'https://m.douban.com/rexxar/api/v2/subject_collection/movie_latest/items',
    freeUrl: 'https://m.douban.com/rexxar/api/v2/subject_collection/movie_free_stream/items',
    detailUrl: 'https://m.douban.com/rexxar/api/v2/movie/'
}

const loadHotFilms = function(params={}) {
    wx.request({
      url: 'URLS.hotUrl',
      data: params,
      success: res => {
          console.log(res)
      }
    })
}

// 模块导出
module.exports = {
    loadHotFilms
}
```

导入使用，回到home.js文件里，在最上面引入模块，同时之前写的loadFilms方法和调用都注释掉
首页加载数据分类有三个，加载数据比较多，可以一个个定义，也可以直接定义一个加载所有数据的方法
```js
    // 加载主页数据
    loadHomeData() {
        // 加载影院热映数据
        api.loadHotFilms({
            start: 0,
            count: 6
        })
        // 加载近期热门数据

        // 加载免费在线数据

    }
```

数据成功打印，但是怎么把数据放到首页，现在是在api.js里打印的
利用promise对于请求再次封装，回到api.js文件里
```js
// 影院热映数据
const loadHotFilms = function(params={}) {
    // 返回Promise对象
    return new Promise((resolve, reject) => {
        wx.request({
            url: URLS.hotUrl,
            data: params,
            success: resolve,
            fail: reject
        })
    }).then( res => {
        // console.log(res)
        if (res.statusCode === 200) {
            return res.data
        } else {
            // 如果失败将Promise状态由fulfilled转换为rejected
            Promise.reject({
                // message换为errMsg是可以处理响应错误，reject(xx)里的xx会作为catch的实参,包括上面fail里的reject的res，失败都会传递给catch里的回调函数
                message: res.errMsg
            })
        }
    })
}
```

### 使用，回到home.js，调用返回Promise对象，接着.then操作，请求失败处理

```js
    // 加载主页数据
    loadHomeData() {
        // 加载影院热映数据
        // 此时调用返回Promise对象
        api.loadHotFilms({
            start: 0,
            count: 6
        }).then(data => {
            let type = {
                title: data.subject_collection.name,
                list: data.subject_collection_items
            }
            // 注意是个对象里面再数组，不能用push
            this.setData({
                'types[0]': type
            }) 
        }).catch(err => {
            // 使用微信小程序提供弹出组件显示请求失败
            wx.showToast({
              // 消息可以自己给
              // title: 'err.errMsg',
              title: '请求失败',
              image: '/imgs/error.png'
            })
        })
        // 加载近期热门数据

        // 加载免费在线数据

    }
```

对于请求错误进行封装(一般不止一个页面可能会发送请求错误)，就在app.js里封装
```js
// 处理请求错误[响应错误这里没做处理]
const showError = function (error) {
    // 使用微信小程序提供弹出组件显示请求失败
    wx.showToast({
      title: error.errMsg,
      // 消息也可以自己给
      // title: '请求失败',
      image: '/imgs/error.png'
    })
}

module.exports = {
    loadHotFilms,
    showError
}
```

home.js调用
```js
    // 加载主页数据
    loadHomeData() {
        // 加载影院热映数据
        // 此时调用返回Promise对象
        api.loadHotFilms({
            start: 0,
            count: 6
        }).then(data => {
            let type = {
                title: data.subject_collection.name,
                list: data.subject_collection_items
            }
            // 注意是个对象里面再数组，不能用push
            this.setData({
                'types[0]': type
            }) 
        }).catch(api.showError) // 注意这里直接放的是函数即回调函数function (xx) { xxx }
        // 加载近期热门数据

        // 加载免费在线数据

    }
```

> 同理另外几个分类数据api封装也是一样，代码如下，记得导出
```js
// 近期热门数据
const loadLatestFilms = function (params = {}) {
    // 返回Promise对象
    return new Promise((resolve, reject) => {
        wx.request({
            url: URLS.latestUrl,
            data: params,
            success: resolve,
            fail: reject
        })
    }).then( res => {
        // console.log(res)
        if (res.statusCode === 200) {
            return res.data
        } else {
            // 如果失败将Promise状态由fulfilled转换为rejected
            Promise.reject({
                // message换为errMsg是可以处理响应错误，reject(xx)里的xx会作为catch的实参,包括上面fail里的reject的res，失败都会传递给catch里的回调函数
                message: res.errMsg
            })
        }
    })
}

// 免费在线数据
const loadFreeFilms = function (params = {}) {
    // 返回Promise对象
    return new Promise((resolve, reject) => {
        wx.request({
            url: URLS.freeUrl,
            data: params,
            success: resolve,
            fail: reject
        })
    }).then( res => {
        // console.log(res)
        if (res.statusCode === 200) {
            return res.data
        } else {
            // 如果失败将Promise状态由fulfilled转换为rejected
            Promise.reject({
                // message换为errMsg是可以处理响应错误，reject(xx)里的xx会作为catch的实参,包括上面fail里的reject的res，失败都会传递给catch里的回调函数
                message: res.errMsg
            })
        }
    })
}
```

home.js中调用
```js
    // 加载主页数据
    loadHomeData() {
        // 加载影院热映数据
        // 此时调用返回Promise对象
        api.loadHotFilms({
            start: 0,
            count: 6
        }).then(data => {
            let type = {
                title: data.subject_collection.name,
                list: data.subject_collection_items
            }
            // 注意是个对象里面再数组，不能用push
            this.setData({
                'types[0]': type
            }) 
        }).catch(api.showError) // 注意这里直接放的是函数即回调函数function (xx) { xxx }

        // 加载近期热门数据
        api.loadLatestFilms({
            start: 0,
            count: 6
        }).then(data => {
            let type = {
                title: data.subject_collection.name,
                list: data.subject_collection_items
            }
            this.setData({
                'types[1]': type
            })
        }).catch(api.showError)

        // 加载免费在线数据
        api.loadFreeFilms({
            start: 0,
            count: 6
        }).then(data => {
            let type = {
                title: data.subject_collection.name,
                list: data.subject_collection_items
            }
            this.setData({
                'types[2]': type
            })
        }).catch(api.showError)
    }
```

### 小程序首页加载优化【三个分类要加载】
> 向后台发请求是需要花时间的，多保存几次，明显看到首页白屏的，过会才显示数据
> loading效果，我们资源文件里有个加载的gif图就用它来做loading效果
> 像这个loading很多页面上都会用到，我们把它定义为一个模板
在项目根目录下创建一个templates文件夹，接着创建loading文件夹，接着创建loading.wxml文件【定义为一个独立的模板文件目的是方便复用】
```html
<view class="loading">
    <image src="/imgs/loading.gif"></image>
    <text>数据加载中</text>
</view>
```

> 在首页中使用，home.wxml中【数据没有出来的时候展示，首页数据都是在一个数据中】
> 模板文件引用使用include标签，注意是在home.wxml文件中引入，放最上面，容器里面即可
```html
    <!-- 显示loading正在加载【数据还没请求到】 -->
    <include src="/templates/loading/loading"/>
```

给loading添加样式，在templates/loading目录下新建loading.wxss文件
> 注意这里有个问题，模板它不是页面，就算同名wxss它也不会加载这个样式，不生效
解决方法：在app.wxss全局导入(加载)样式文件
app.wxss代码如下
```css
/* 全局导入loading */
@import "/templates/loading/loading.wxss";

page {
    background-color: #efefef;
}
```

loading.wxss代码如下
```css
.loading {
    width: 100%;
    text-align: center;
    margin-top: 40rpx;
}

.loading image {
    width: 80rpx;
    height: 80rpx;
}

.loading view {
    font-size: 22rpx;
    color: #333;
}
```

> 有无数据直接通过判断数据长度就行了，直接使用wx:if指令即可

回到home.wxml添加指令
```html
    <!-- 显示loading正在加载【数据还没请求到】 -->
    <include wx:if="{{ types.length === 0 }}" src="/templates/loading/loading"/>
```

> 如果想人为让loading效果时间长一点，可以使用延时器把加载主页数据调用进行包裹即可
```js
    // 人为让loading效果时间长一点，只需要让发请求晚一点发即可
    setTimeout(() => {
        this.loadHomeData()
    }, 3000)
```

## 分类页数据对接
> 首页是已经传递数据了，但是咱们分类页数据还没传递
> 点击更多，有三个分类，影院热映或者近期热门或者免费在线，那怎么知道向哪个接口发请求？

解决思路：每个分类里的更多都是由调用请求api里的方法得到的，我们可以往res.data里面添加method属性，告诉我是由哪个api方法请求的数据
api.js文件
```js
res.data.method = 'loadHotFilms'
return res.data
```

```js
res.data.method = 'loadLatestFilms'
return res.data
```

```js
res.data.method = 'loadFreeFilms'
return res.data
```

进入home.js文件中，我们需要把请求时这个method保存到home页面组件的data中，再通过首页进入分类页把数据传递过去即可
加载主页数据
```js
let type = {
    title: data.subject_collection.name,
    list: data.subject_collection_items,
    // 都要加上下面这个
    method: data.method
}
```

加载近期热门数据
```js
let type = {
    title: data.subject_collection.name,
    list: data.subject_collection_items,
    // 都要加上下面这个
    method: data.method
}
```

加载免费在线数据
```js
let type = {
    title: data.subject_collection.name,
    list: data.subject_collection_items,
    // 都要加上下面这个
    method: data.method
}
```

home.wxml传递数据过去，导航跳转（路由跳转传参，注意它是个变量，咱们加上{{}}）
```html
<navigator url="/pages/list/list?method={{ item.method }}">更多 ></navigator>
```

验证数据是否成功传递过来，进入list.js文件，接收参数都是用onLoad做有个options
```js
    onLoad: function (options) {
        console.log(options); // 成功拿到
    },
```

放到数据仓库中【data】
定义初始数据，并给初始数据赋值

> 【注意】放到数据仓库中，这里赋值为何不采用setData呢？
解答：`this.setData`是可以实现数据的响应式，只要页面用到的地方都能及时的更新，但是`method`的值我们只需要固定的，并且不需要在页面上展示，所以这里两个方法都可以
```js
    /**
     * 页面的初始数据
     */
    data: {
        method: '', // 调api的方法名
    },
    /**
     * 生命周期函数--监听页面加载
     */
    onLoad: function (options) {
        console.log(options); // 成功拿到method
        // 放到数据仓库中
        this.data.method = options.method
        // 这里赋值为何不采用setData呢？
        // this.setData是可以实现数据的响应式，只要页面用到的地方都能及时的更新，但是method的值我们只需要固定的，并且不需要在页面上展示，所以这里两个方法都可以
        // this.setData({
        //     method: options.method
        // })
    },
```

定义加载数据的方法，导入api模块
```js
// 导入api模块
const api = require('../../api/api.js')
---
    // 定义加载数据方法
    loadListData() {
        // 注意method是个变量这里要用中括号
        api[this.data.method]({
            start: 0,
            count: 12
        }).then(data => {
            console.log(data) // 成功拿到数据
        }).catch(api.showError)
    },
```

拿到数据后我们需要存放到数据仓库中，同时它还有个分类在里面，这里涉及数据为对象
```js
    /**
     * 页面的初始数据
     */
    data: {
        method: '', // 调api的方法名
        films: {} // 存放电影信息，由于有个分类名，这里设计为对象格式的数据
    },
```

接着处理数据，赋值给films
```js
    // 定义加载数据方法
    loadListData() {
        // 注意method是个变量这里要用中括号
        api[this.data.method]({
            start: 0,
            count: 12
        }).then(data => {
            console.log(data) // 成功拿到数据
            // 定义一个films，再赋值给数据仓库中的films即可
            let films = {
                title: data.subject_collection.name,
                list: data.subject_collection_items
            }
            this.setData({
                // films: films
                // 由于对象属性名与属性值的变量名相同可以简写为films
                films
            })
        }).catch(api.showError)
        // 这个写完可以测试一下，学会使用控制台的AppData，它是可以帮我们看这个数据的，如films中的title和list
    },
```

> 这个写完可以测试一下，学会使用控制台的`AppData`，它是可以帮我们看这个数据的，如`films`中的`title`和`list`

list.js代码如下
```js
// pages/list/list.js
// 导入api模块
const api = require('../../api/api.js')
Page({

    /**
     * 页面的初始数据
     */
    data: {
        method: '', // 调api的方法名
        films: {} // 存放电影信息，由于有个分类名，这里设计为对象格式的数据
    },

    /**
     * 生命周期函数--监听页面加载
     */
    onLoad: function (options) {
        console.log(options); // 成功拿到method
        // 放到数据仓库中
        this.data.method = options.method
        // 这里赋值为何不采用setData呢？
        // this.setData是可以实现数据的响应式，只要页面用到的地方都能及时的更新，但是method的值我们只需要固定的，并且不需要在页面上展示，所以这里两个方法都可以
        // this.setData({
        //     method: options.method
        // })
        this.loadListData()
    },
    // 定义加载数据方法
    loadListData() {
        // 注意method是个变量这里要用中括号
        api[this.data.method]({
            start: 0,
            count: 12
        }).then(data => {
            console.log(data) // 成功拿到数据
            // 定义一个films，再赋值给数据仓库中的films即可
            let films = {
                title: data.subject_collection.name,
                list: data.subject_collection_items
            }
            this.setData({
                // films: films
                // 由于对象属性名与属性值的变量名相同可以简写为films
                films
            })
        }).catch(api.showError)
        // 这个写完可以测试一下，学会使用控制台的AppData，它是可以帮我们看这个数据的，如films中的title和list
    },
    /**
     * 生命周期函数--监听页面初次渲染完成
     */
    onReady: function () {

    },

    /**
     * 生命周期函数--监听页面显示
     */
    onShow: function () {

    },

    /**
     * 生命周期函数--监听页面隐藏
     */
    onHide: function () {

    },

    /**
     * 生命周期函数--监听页面卸载
     */
    onUnload: function () {

    },

    /**
     * 页面相关事件处理函数--监听用户下拉动作
     */
    onPullDownRefresh: function () {

    },

    /**
     * 页面上拉触底事件的处理函数
     */
    onReachBottom: function () {

    },

    /**
     * 用户点击右上角分享
     */
    onShareAppMessage: function () {

    }
})
```

展示数据如分类、电影，进入list.js文件中
list.js代码如下
```html
<!--pages/list/list.wxml-->
<view>
    <view class="list-type">
        <view class="type-title">
            <!-- <text>近期热门电影</text> -->
            <!-- 替换为数据仓库中的数据 -->
            <text>{{ films.title }}</text>
        </view>
        <view class="film-list">
            <!-- <film-item class="film-item" wx:for="{{ 12 }}" wx:key="index"></film-item> -->
            <!-- 替换为数据仓库中的数据，同时film-item组件还需要传递值过去，item即为电影列表中的每一项 -->
            <film-item class="film-item" wx:for="{{ films.list }}" film="{{ item }}" wx:key="index"></film-item>
        </view>
    </view>
</view>
```

### 上拉加载更多数据
分类页面的这个数据是有total的，但是目前我们只请求了12条，有的已经超过了12条，我们本来就是要看电影的只加载12条显然不合适，但是一下子请求如500条也不合适，需要考虑用户体验，加载太慢数据一直不出来，占用网络带宽，先只加载12条，用户手指下滑或上拉加载更多电影，当电影加载完，显示没有更多了

> 上拉加载：小程序框架/框架接口/页面Page中是有一个这样的事件监听的函数的`onReachBottom`页面上拉触底事件的处理函数

回到list.js文件中
```js
    /**
     * 页面上拉触底事件的处理函数
     */
    onReachBottom: function () {
        console.log(123) // 这里我们可以测试一下上拉功能
        // 发请求获取数据由于起始索引是从0开始，但是下次加载就不能从0开始了，说明start不能写死，需要去数据仓库中定义数据，count是返回多少条数据，也可以不用写死
        this.loadListData() // 调用加载电影数据的方法
    },
```

上面这样调用加载数据方法还不行，需要改造loadListData方法

发请求获取数据由于起始索引是从0开始，但是下次加载就不能从0开始了，说明start不能写死，需要去数据仓库中定义数据，count是返回多少条数据，也可以不用写死
```js
    /**
     * 页面的初始数据
     */
    data: {
        method: '', // 调api的方法名
        films: {}, // 存放电影信息，由于有个分类名，这里设计为对象格式的数据
        start: 0, // 起始索引
        count: 12 // 返回多少条数据
    },
```

更改完，初始加载数据的那个方法也可以更改了
同时也出现一个问题--->当每次有人上拉时调请求数据方法，起始索引值都要比之前多12
解决方案：我们可以每次请求完数据，在`then`里面更改`start`值为`start+count`
```js
    // 定义加载数据方法
    loadListData() {
        // 注意method是个变量这里要用中括号
        api[this.data.method]({
            start: this.data.start,
            count: this.data.count
        }).then(data => {
            // console.log(data) // 成功拿到数据
            // 定义一个films，再赋值给数据仓库中的films即可
            let films = {
                title: data.subject_collection.name,
                list: data.subject_collection_items
            }
            this.setData({
                // films: films
                // 由于对象属性名与属性值的变量名相同可以简写为films
                films,
                start: this.data.start + this.data.count // 起始索引增加
            })
        }).catch(api.showError)
        // 这个写完可以测试一下，学会使用控制台的AppData，它是可以帮我们看这个数据的，如films中的title和list
    },
```

新的问题也出现了，它总是显示新的12条，原来的数据没了
解决方案：之前我们使用的films是将每次获取的电影films直接赋值给数据仓库中的films，很显然它就一直都是新的12条，我们只需要做电影数据的concat累加即可
其中需要注意细节，初始`films`中由于没有`list`即`list`为`undefined`不能使用`concat`方法需要给它赋个[]空数组
我们更改的只是list
```js
    // 定义加载数据方法
    loadListData() {
        // 注意method是个变量这里要用中括号
        api[this.data.method]({
            start: this.data.start,
            count: this.data.count
        }).then(data => {
            // console.log(data) // 成功拿到数据
            // 初始films中没有list，即list为undefined不能使用concat方法需要给它赋个[]空数组
            let list = this.data.films.list || []
            // 定义一个films，再赋值给数据仓库中的films即可
            let films = {
                title: data.subject_collection.name,
                // list: data.subject_collection_items
                list: list.concat(data.subject_collection_items) // 上拉加载时数据累加
            }
            this.setData({
                // films: films
                // 由于对象属性名与属性值的变量名相同可以简写为films
                films,
                start: this.data.start + this.data.count // 起始索引增加
            })
        }).catch(api.showError)
        // 这个写完可以测试一下，学会使用控制台的AppData，它是可以帮我们看这个数据的，如films中的title和list
    },
```

我们可以在控制台Network的XHR中查看Name注意往上面拉一下有些在下方挡住了，会有个Name，我们可以点击，右边还会出现Headers、Preview和Reponse等信息

### 上拉加载细节优化
> 优化一
模拟加载的延迟，当用户上拉时，如果说数据请求很长时间才请求到，那么用户是能明显感觉得到没有这种上拉的效果在里面，为了用户体验感的做优化处理
如何模拟？
和之前一样使用延时器发请求加载数据即可--->调那个loadListData方法
```js
    /**
     * 页面上拉触底事件的处理函数
     */
    onReachBottom: function () {
        setTimeout(() => {
            this.loadListData()
        }, 3000) // 模拟加载延迟，调用加载电影数据的方法
    },
```

怎么优化呢？
之前我们就写过加载动画(loading)的模板了，这里我们也给它加上这个，进入list.wxml文件中，最下方加上如下代码
```html
    <!-- 显示loading正在加载 -->
    <include src="/templates/loading/loading" />
```

但是这里注意一个问题，这个loading其实一直都在，我们还需要处理什么时候loading不需要了--->数据加载完【有数据了，成功拿到数据了】
开关法--->使用一个布尔值即可，在list.js数据仓库中定义一个showLoading
```js
    /**
     * 页面的初始数据
     */
    data: {
        method: '', // 调api的方法名
        films: {}, // 存放电影信息，由于有个分类名，这里设计为对象格式的数据
        start: 0, // 起始索引
        count: 12, // 返回多少条数据
        showLoading: false // 是否显示loading，只有上拉加载数据还未响应时需要显示loading--->所以设置为false
    },
```

回到list.wxml中，添加判断是否显示
```html
    <!-- 显示loading正在加载 -->
    <include wx:if="{{ showLoading }}" src="/templates/loading/loading" />
```

上拉时还需要显示`loading`，同时拿到数据让`loading`隐藏
【注意发请求拿数据，调用`api`是异步，能直接在下面更改布尔值？】
很显然不能，解决方案
我们的`api`是基于`promise`封装的，不管是`.then`还是`.catch`，它们最终得到的还是`promise`对象，我们只需要在loadListData函数中把那个`promise`对象给return出去即可，接着进行`.then`操作
```js
    // 定义加载数据方法
    loadListData() {
        // 注意method是个变量这里要用中括号
        // 返回Promise对象，便于继续执行
        return api[this.data.method]({
            start: this.data.start,
            count: this.data.count
        }).then(data => {
            // console.log(data) // 成功拿到数据
            // 初始films中没有list，即list为undefined不能使用concat方法需要给它赋个[]空数组
            let list = this.data.films.list || []
            // 定义一个films，再赋值给数据仓库中的films即可
            let films = {
                title: data.subject_collection.name,
                // list: data.subject_collection_items
                list: list.concat(data.subject_collection_items) // 上拉加载时数据累加
            }
            this.setData({
                // films: films
                // 由于对象属性名与属性值的变量名相同可以简写为films
                films,
                start: this.data.start + this.data.count // 起始索引增加
            })
        }).catch(api.showError)
        // 这个写完可以测试一下，学会使用控制台的AppData，它是可以帮我们看这个数据的，如films中的title和list
    },
    /**
     * 页面上拉触底事件的处理函数
     */
    onReachBottom: function () {
        // console.log(123) // 这里我们可以测试一下上拉功能

        // 上拉时先让loading显示
        this.setData({
            showLoading: true
        })

        // 发请求获取数据由于起始索引是从0开始，但是下次加载就不能从0开始了，说明start不能写死，需要去数据仓库中定义数据，count是返回多少条数据，也可以不用写死
        // this.loadListData() // 调用加载电影数据的方法
        setTimeout(() => {
            // 这里的.then一定别忘了上面要loadListData要加上return
            this.loadListData().then(() => {
                // 加载完数据隐藏loading
                this.setData({
                    showLoading: false
                })
            })
        }, 3000) // 模拟加载延迟，调用加载电影数据的方法
    },
```

测试阶段，点击AppData，在运行的页面上进行上拉操作，查看list页面的showLoading值的变化
`false--->true--->false`

> 优化二
如果后台没数据给你返回了，那么就没必要再发无意义的请求，依旧是在上拉加载中处理
【问题】怎么判断还有数据？
这时候`total`就发挥作用了，后台返回数据中一般对于`list`这种它都会给我们返回`total`这么一个字段的，通过它能告诉我们还有多少条数据可以取，同时在数据仓库中定义一个`total`，把响应数据里的`total`给它存起来
```js
    /**
     * 页面的初始数据
     */
    data: {
        method: '', // 调api的方法名
        films: {}, // 存放电影信息，由于有个分类名，这里设计为对象格式的数据
        start: 0, // 起始索引
        count: 12, // 返回多少条数据
        total: 0, // 后台数据库中电影总条数
        showLoading: false // 是否显示loading，只有上拉加载数据还未响应时需要显示loading--->所以设置为false
    },
```

发完请求还需要赋值total
```js
    this.setData({
        // films: films
        // 由于对象属性名与属性值的变量名相同可以简写为films
        films,
        start: this.data.start + this.data.count, // 起始索引增加
        total: data.total // 后台数据库中电影总条数
    })
```

上拉只有在后台数据库中还有数据才发请求调用加载数据的方法，如何判断还有数据？
通过`start < total`

```js
    /**
     * 页面上拉触底事件的处理函数
     */
    onReachBottom: function () {
        // console.log(123) // 这里我们可以测试一下上拉功能

        // 判断是否还有更多数据，如果有就显示loading再加载数据；没有最好显示没有更多数据
        if (this.data.start < this.data.total) {
            // 上拉时先让loading显示
            this.setData({
                showLoading: true
            })
            // 发请求获取数据由于起始索引是从0开始，但是下次加载就不能从0开始了，说明start不能写死，需要去数据仓库中定义数据，count是返回多少条数据，也可以不用写死
            // this.loadListData() // 调用加载电影数据的方法
            setTimeout(() => {
                // 这里的.then一定别忘了上面要loadListData要加上return
                this.loadListData().then(() => {
                    // 加载完数据隐藏loading
                    this.setData({
                        showLoading: false
                    })
                })
            }, 3000) // 模拟加载延迟，调用加载电影数据的方法
        }
    },
```

当后台数据库中没有数据时需要显示没有更多数据，考虑到在很多页面中也会用到，所以把它封装为一个模板，单独定义没有更多的这样一个模板
在`templates`目录下新建`nomore`文件夹，接着在该文件夹下新建文件`nomore.wxml`和`nomore.wxss`
`nomore.wxml`代码如下
```html
<view class="nomore">~~没有更多了~~</view>
```

`nomore.wxss`代码如下
```css
.nomore {
    text-align: center;
    font-size: 28rpx;
    color: #999;
    margin-bottom: 30rpx;
}
```

前面之前说到过了，模板的样式文件需要做全局导入(加载)样式文件
进入`app.wxss`文件中，完整代码如下
```css
/* 全局导入loading */
@import "/templates/loading/loading.wxss";
/* 全局导入nomore */
@import "/templates/nomore/nomore.wxss";

page {
    background-color: #efefef;
}
```

回到`list.wxml`页面中最后面加上这个`nomore`模板，没有更多数据时需要让其生效，需要一个布尔值来控制其显示隐藏
```html
    <!-- 显示nomore没有更多数据 -->
    <include wx:if="{{ showNomore }}" src="/templates/nomore/nomore" />
```

同时回到`list.js`中，到数据仓库中添加`showNomore`，值默认为`false`
```js
    /**
     * 页面的初始数据
     */
    data: {
        method: '', // 调api的方法名
        films: {}, // 存放电影信息，由于有个分类名，这里设计为对象格式的数据
        start: 0, // 起始索引
        count: 12, // 返回多少条数据
        total: 0, // 后台数据库中电影总条数
        showLoading: false, // 是否显示loading，只有上拉加载数据还未响应时需要显示loading--->所以设置为false
        showNomore: false // 是否显示nomore
    },
```

什么时候改为`true`，当没有数据的时候，也就是`else`，改为`true`
```js
    /**
     * 页面上拉触底事件的处理函数
     */
    onReachBottom: function () {
        // console.log(123) // 这里我们可以测试一下上拉功能

        // 判断是否还有更多数据，如果有就显示loading再加载数据；没有最好显示没有更多数据
        if (this.data.start < this.data.total) { // 还有更多数据
            // 上拉时先让loading显示
            this.setData({
                showLoading: true
            })
            // 发请求获取数据由于起始索引是从0开始，但是下次加载就不能从0开始了，说明start不能写死，需要去数据仓库中定义数据，count是返回多少条数据，也可以不用写死
            // this.loadListData() // 调用加载电影数据的方法
            setTimeout(() => {
                // 这里的.then一定别忘了上面要loadListData要加上return
                this.loadListData().then(() => {
                    // 加载完数据隐藏loading
                    this.setData({
                        showLoading: false
                    })
                })
            }, 3000) // 模拟加载延迟，调用加载电影数据的方法
        } else { // 没有更多数据，显示nomore
            this.setData({
                showNomore: true
            })
        }
    },
```

### 下拉刷新
和上拉加载一样也有一个监听下拉刷新的事件处理函数即`onPullDownRefresh`，首先需要在`list.json`中启用它
【注意】但是有个问题它的效果不是很明显，需要给它加样式，`backgroundColor`是下拉的那个背景色，`backgroundTextStyle`是三个点点点的样式，只有`dark`和`light`可选
```json
{
  "usingComponents": {},
  "enablePullDownRefresh": true,
  "backgroundColor": "#efefef",
  "backgroundTextStyle": "dark"
}
```

上面这些设置只是效果上的，忽悠人的，下拉刷新我们还需要使用那个函数重新加载新的数据，回到`list.js`文件中，使用`onPullDownRefresh`函数
怎么重新加载新的数据？
把值都恢复默认就行了
```js
    /**
     * 页面相关事件处理函数--监听用户下拉动作
     */
    onPullDownRefresh: function () {
        // 重新加载数据即把值都恢复默认就行了
        this.setData({
            start: 0,
            films: {}
        })
        this.loadListData()
    },
```

测试，我们可以在调试器中的`Network`中观察这个`start`是不是变成0了

`list.js`完整代码如下
```js
// pages/list/list.js
// 导入api模块
const api = require('../../api/api.js')
Page({

    /**
     * 页面的初始数据
     */
    data: {
        method: '', // 调api的方法名
        films: {}, // 存放电影信息，由于有个分类名，这里设计为对象格式的数据
        start: 0, // 起始索引
        count: 12, // 返回多少条数据
        total: 0, // 后台数据库中电影总条数
        showLoading: false, // 是否显示loading，只有上拉加载数据还未响应时需要显示loading--->所以设置为false
        showNomore: false // 是否显示nomore
    },

    /**
     * 生命周期函数--监听页面加载
     */
    onLoad: function (options) {
        // console.log(options); // 成功拿到method
        // 放到数据仓库中
        this.data.method = options.method
        // 这里赋值为何不采用setData呢？
        // this.setData是可以实现数据的响应式，只要页面用到的地方都能及时的更新，但是method的值我们只需要固定的，并且不需要在页面上展示，所以这里两个方法都可以
        // this.setData({
        //     method: options.method
        // })
        this.loadListData()
    },
    // 定义加载数据方法
    loadListData() {
        // 注意method是个变量这里要用中括号
        // 返回Promise对象，便于继续执行
        return api[this.data.method]({
            start: this.data.start,
            count: this.data.count
        }).then(data => {
            // console.log(data) // 成功拿到数据
            // 初始films中没有list，即list为undefined不能使用concat方法需要给它赋个[]空数组
            let list = this.data.films.list || []
            // 定义一个films，再赋值给数据仓库中的films即可
            let films = {
                title: data.subject_collection.name,
                // list: data.subject_collection_items
                list: list.concat(data.subject_collection_items) // 上拉加载时数据累加
            }
            this.setData({
                // films: films
                // 由于对象属性名与属性值的变量名相同可以简写为films
                films,
                start: this.data.start + this.data.count, // 起始索引增加
                total: data.total // 后台数据库中电影总条数
            })
        }).catch(api.showError)
        // 这个写完可以测试一下，学会使用控制台的AppData，它是可以帮我们看这个数据的，如films中的title和list
    },
    /**
     * 生命周期函数--监听页面初次渲染完成
     */
    onReady: function () {

    },

    /**
     * 生命周期函数--监听页面显示
     */
    onShow: function () {

    },

    /**
     * 生命周期函数--监听页面隐藏
     */
    onHide: function () {

    },

    /**
     * 生命周期函数--监听页面卸载
     */
    onUnload: function () {

    },

    /**
     * 页面相关事件处理函数--监听用户下拉动作
     */
    onPullDownRefresh: function () {
        // 重新加载数据即把值都恢复默认就行了
        this.setData({
            start: 0,
            films: {}
        })
        this.loadListData()
    },

    /**
     * 页面上拉触底事件的处理函数
     */
    onReachBottom: function () {
        // console.log(123) // 这里我们可以测试一下上拉功能

        // 判断是否还有更多数据，如果有就显示loading再加载数据；没有最好显示没有更多数据
        if (this.data.start < this.data.total) { // 还有更多数据
            // 上拉时先让loading显示
            this.setData({
                showLoading: true
            })
            // 发请求获取数据由于起始索引是从0开始，但是下次加载就不能从0开始了，说明start不能写死，需要去数据仓库中定义数据，count是返回多少条数据，也可以不用写死
            // this.loadListData() // 调用加载电影数据的方法
            setTimeout(() => {
                // 这里的.then一定别忘了上面要loadListData要加上return
                this.loadListData().then(() => {
                    // 加载完数据隐藏loading
                    this.setData({
                        showLoading: false
                    })
                })
            }, 3000) // 模拟加载延迟，调用加载电影数据的方法
        } else { // 没有更多数据，显示nomore
            this.setData({
                showNomore: true
            })
        }
    },

    /**
     * 用户点击右上角分享
     */
    onShareAppMessage: function () {

    }
})
```

## 详情页
### 绘制详情页
在`pages`目录下新建一个文件夹为`detail`，接着在里面鼠标右键选择新建`Page`，输入`detail`回车即可，这样页面就创建好了

每项电影都是我们的`film-item`组件，点击跳转到详情页，只需要更改`film-item`组件，把最外层的`view`换成`navigator`就可以了，并添加上跳转地址`url="/pages/detail/detail"`
```html
<!-- 最外层view标签替换为下面这个 -->
<navigator url="/pages/detail/detail">
</navigator>
```

为了方便观察详情页，我们去`app.json`把`pages`中的`detail`放最前面，这样应用就会直接显示详情页
```json
    "pages": [
        "pages/detail/detail",
        "pages/home/home",
        "pages/list/list",
        "pages/about/about"
    ],
```

进入`detail.wxml`，把默认内容清除掉，首先放容器`view`，根据设计图，划分板块，书写布局和样式代码
代码比较多这里我就不做展示了，大家可以拉取代码仓库进入`/pages/detail`文件夹下查看

### 电影详情页数据的加载
> 首先看下**电影详情**的接口地址`https://m.douban.com/rexxar/api/v2/movie/电影ID`，我们可以发现这里传参的方式并不是采用传统`?`的方式，而是写在路径里作为路径的一部分，我们叫它Rest风格

回到`api.js`文件中，封装请求api
```js
// 电影详情页数据
const loadFilmByFilmId = function (filmId) {
    return new Promise((resolve, reject) => {
        wx.request({
            url: URLS.detailUrl + filmId,
            success: resolve,
            fail: reject
        })
    }).then(res => {
        if (res.statusCode == 200) {
            return res.data
        } else {
            return Promise.reject({
                message: res.errMsg
            })
        }
    })
}

// 注意要暴露出去
module.exports = {
    showError,
    loadHotFilms,
    loadLatestFilms,
    loadFreeFilms,
    loadFilmByFilmId
}
```

进入`app.json`文件中，把首页放到最上面
```json
    "pages": [
        "pages/home/home",
        "pages/detail/detail",
        "pages/list/list",
        "pages/about/about"
    ],
```

我们要传递电影的id给到详情页，进入`film-item.wxml`文件中，`url`后面拼接`id`，注意`film`里面是有个`id`的，如果你之前在控制台仔细查看过数据，是会发现有个`id`的
```html
<navigator url="/pages/detail/detail?filmId={{ film.id }}">
</navigator>
```

接收`filmId`，同时把它保存到我们的数据仓库中，进入`detail.js`文件中
```js
    /**
     * 页面的初始数据
     */
    data: {
        filmId: '', // 电影id
    },

    /**
     * 生命周期函数--监听页面加载
     */
    onLoad(options) {
        this.data.filmId = options.filmId
    },
```

导入`api`，在`onReady`中发请求
```js
const api = require('../../api/api')

    /**
     * 生命周期函数--监听页面初次渲染完成
     */
    onReady() {
        api.loadFilmByFilmId(this.data.filmId).then(data => {
            // console.log(data); // 成功返回电影信息
            // 将它们保存到数据仓库中，页面上需要直接使用
            this.setData({
                film: data
            })
        }).catch(api.showError)
    },
```

展示电影数据，进入`detail.wxml`文件中，控制台的`AppData`打开，找到数据仓库中的`film`，到其中找数据，看哪个字段合适放上去
【注意: 由于接口问题】演员的图片那里目前少数据，所以没更换，然后评论数据是有个单独的数据接口

### 电影评论数据的加载
> 分析这个获取评论的接口地址，我们可以发现它前面是`detailUrl`的地址【rest风格】但是后面又是查询字符串格式，所以我们可以直接使用`detailUrl`，没有将它单独写到统一的`URLS`中，然后后面拼接参数即可
进入`api.js`文件中，封装获取评论数据的接口
```js
// 电影详情页评论数据
const loadCommentsByFilmId = function (filmId,params={}) {
    return new Promise((resolve, reject) => {
        wx.request({
          url: URLS.detailUrl+filmId+'/interests',
          data:params,
          success: resolve,
          fail: reject
        })
    }).then(res => {
        if (res.statusCode == 200) {
            return res.data
        } else {
            return Promise.reject({
                message: res.errMsg
            })
        }
    })
}

// 注意要暴露出去
module.exports = {
    showError,
    loadHotFilms,
    loadLatestFilms,
    loadFreeFilms,
    loadFilmByFilmId,
    loadCommentsByFilmId
}
```

回到`detail.js`文件中，调用接口获取数据
首先需要在数据仓库定义两个字段
```js
    /**
     * 页面的初始数据
     */
    data: {
        filmId: '', // 电影id
        film: {}, // 存储电影信息
        start: 0, // 评论的起始索引
        count: 10, // 评论的条数
        comments: [], // 存储电影的评论
    },
```
接着依旧是在`onReady`中发请求
```js
    /**
     * 生命周期函数--监听页面初次渲染完成
     */
    onReady() {
        api.loadFilmByFilmId(this.data.filmId).then(data => {
            // console.log(data); // 成功返回电影信息
            // 将它们保存到数据仓库中，页面上需要直接使用
            this.setData({
                film: data
            })
        }).catch(api.showError)
        // 单独加载电影的评论
        api.loadCommentsByFilmId(this.data.filmId, {
            start: this.data.start,
            count: this.data.count,
            order_by: 'time' // 时间的降序，最新评论在最上面
        }).then(data => {
            console.log(data); // 打印下data，找到评论数据
            this.setData({
                comments: data.interests
            })
        }).catch(api.showError)
    },
```

接着我们可以在`AppData`中看下我们的数据仓库中有没有评论数据
展示数据，进入`detail.wxml`文件中
```html
    <!-- 电影评论 start -->
    <view class="film-comment">
        <view class="comment-title">
            <text>评论：</text>
        </view>
        <view class="comment-item" wx:for="{{ comments }}" wx:for-item="comment" wx:key="index">
            <view class="left">
                <image class="user-img" src="{{ comment.user.avatar }}"></image>
            </view>
            <view class="right">
                <view class="name">{{ comment.user.name }}</view>
                <view class="time">{{ comment.create_time }}</view>
                <view class="content">{{ comment.comment }}</view>
            </view>
        </view>
    </view>
    <!-- 电影评论 end -->
```

### 上拉加载更多评论
> 依旧是使用`onReachBottom`这个函数
在数据仓库的把总的数据条数存储起来
```js
    /**
     * 页面的初始数据
     */
    data: {
        filmId: '', // 电影id
        film: {}, // 存储电影信息
        start: 0, // 评论的起始索引
        count: 10, // 评论的条数
        total: 0, // 总的评论条数
        comments: [], // 存储电影的评论
    },
```

同时起始索引也还要加，`total`存储起来，评论数组，要与新的评论数组合并
```js
    /**
     * 生命周期函数--监听页面初次渲染完成
     */
    onReady() {
        api.loadFilmByFilmId(this.data.filmId).then(data => {
            // console.log(data); // 成功返回电影信息
            // 将它们保存到数据仓库中，页面上需要直接使用
            this.setData({
                film: data
            })
        }).catch(api.showError)
        // 单独加载电影的评论
        api.loadCommentsByFilmId(this.data.filmId, {
            start: this.data.start,
            count: this.data.count,
            order_by: 'time' // 时间的降序，最新评论在最上面
        }).then(data => {
            console.log(data); // 打印下data，找到评论数据
            this.setData({
                // comments: data.interests, // 评论数据
                comments: this.data.comments.concat(data.interests), // 评论数组的累加
                start: this.data.start + this.data.count, // 起始索引每次累加
                total: data.total // 记录总条数
            })
        }).catch(api.showError)
    },
```

判断后台有没有多的数据，让你去请求，没有就显示没有更多，在`onReachBottom`这个函数中判断
加载评论单独抽离成一个方法`loadComments`，因为考虑到上拉加载每次只需要加载评论即可【封装代码这里不做展示了，具体可以拉取代码查看`detail.js`文件】
```js
    /**
     * 页面上拉触底事件的处理函数
     */
    onReachBottom() {
        if (this.data.start < this.data.total) {
            this.loadComments()
        }
    },
```
为了考虑用户体验，发请求获取数据需要时间，显示loading效果，同时没有评论了，显示没有更多
这里我们把`list.wxml`中的`loading`和`nomore`代码给复制过来粘贴到`detail.wxml`中，同时到数据仓库中定义控制显示、隐藏的数据
```js
    /**
     * 页面的初始数据
     */
    data: {
        filmId: '', // 电影id
        film: {}, // 存储电影信息
        start: 0, // 评论的起始索引
        count: 10, // 评论的条数
        total: 0, // 总的评论条数
        comments: [], // 存储电影的评论
        showLoading: false, // loading的开关
        showNomore: false // 没有更多的开关
    },
```

`loading`和`nomore`显示隐藏
```js
    /**
     * 页面上拉触底事件的处理函数
     */
    onReachBottom() {
        if (this.data.start < this.data.total) { // 有数据
            // 为了考虑用户体验，发请求获取数据需要时间，显示loading效果
            this.setData({
                showLoading: true
            })
            // 注意拿到数据之后才能再让loading隐藏，但是发请求是个异步，我们需要借助promise.then，即把之前加载评论数据封装的方法里的promise对象return出来即可
            this.loadComments().then(() => {
                this.setData({
                    showLoading: false // 拿到返回的评论数据
                })
            })
        } else { // 没有更多数据
            this.setData({
                nomore: true
            })
        }
    },
```

这里我们可以发现当初把`loading`和`nomore`抽离成模板的好处了，很多地方都会用到
最后还有一个收藏功能未实现，这里等我们把个人页【关于页】做了再来实现

## 关于页及授权登录的实现
### 绘制关于页面
这里`wxml`和`wxss`代码我就不做展示了，可以到`about`文件夹下查看

### 用户授权登陆
使用按钮里绑定的`getUserProfile`函数，用户信息拿到了将它存储到数据仓库中
```js
    /**
     * 页面的初始数据
     */
    data: {
        userInfo: null, // 存储局部用户信息
    },
    getUserProfile(e) { // 获取用户信息【这个事件对象建议带上】
        // 【注意wx.getUserProfile必须搭配点击事件才能使用】推荐使用 wx.getUserProfile 获取用户信息，开发者每次通过该接口获取用户个人信息均需用户确认
        // 开发者妥善保管用户快速填写的头像昵称，避免重复弹窗
        wx.getUserProfile({
          desc: '用于完善用户个人信息',
          success: res => {
            //   console.log(res);
              this.setData({
                  userInfo: res.userInfo
              })
              app.userInfo = res.userInfo // 考虑到很多页面会使用用户信息，添加到全局实例中
          }
        })
    },
```

回到`about.wxml`文件中展示用户信息，需要使用或运算符，只有当数据仓库中有用户信息才展示用户信息，没有显示默认的
```html
    <!-- 用户信息 start -->
    <view class="userinfo">
        <image class="user-img" src="{{ userInfo.avatarUrl || '/imgs/user.png' }}"></image>
        <!-- 昵称默认没授权不显示 -->
        <view wx:if="{{ userInfo }}" class="user-nickname">{{ userInfo.nickName }}</view>
        <!-- plain镂空 -->
        <button wx:else class="login" plain bindtap="getUserProfile">点击授权登陆</button>
    </view>
    <!-- 用户信息 end -->
```
需要注意一个问题，如果授权登陆了，数据是会存储到本地缓存中的，但是下次再进来还要再点一下按钮才能显示用户头像和昵称？
【原先的getUserInfo解决方案】
也就是说当小程序启动时就要尝试去获取本地缓存中的用户信息，如果用户已经授权过了，用户进入`about`页面就要直接展示用户头像和昵称，小程序启动是在`app.js`，进入`app.js`文件中，启动时获取到的用户信息，咱们需要把这个用户信息定义为全局的，全局存储这个用户信息，然后再到`about.js`文件中，当`about`页面加载时，判断全局用户信息有没有，如果有就获取并放到`about`里的局部用户信息中，注意需要获取全局实例`app`才能拿到用户信息；考虑到用户信息很多页面可能会用到，所以添加到全局实例中，需要注意一个问题，小程序启动过程中有个获取用户信息，而获取用户信息是个异步的过程，可能出现关于页面还拿着全局用户信息`null`直接加载完了页面，显然这是小程序和页面加载时机的问题，解决方法就是给全局实例绑定回调，然后判断有没有这个`callback`，如果有就调用并把结果作为实参传递进去。

【目前直接用同步缓存`wx.setStorageSync`和`wx.getStorageSync`方法】
```js
    /**
     * 生命周期函数--监听页面加载
     */
    onLoad: function (options) {
        let userInfo = wx.getStorageSync('userInfo') // 从本地存储中获取用户信息
        this.setData({
            userInfo
        })
    },
    getUserProfile(e) { // 获取用户信息【这个事件对象可传可不传】
    // 【注意wx.getUserProfile必须搭配点击事件才能使用】推荐使用 wx.getUserProfile 获取用户信息，开发者每次通过该接口获取用户个人信息均需用户确认
    // 开发者妥善保管用户快速填写的头像昵称，避免重复弹窗
    wx.getUserProfile({
          desc: '用于完善用户个人信息',
          success: res => {
            //   console.log(res);
                this.setData({
                    userInfo: res.userInfo,
                    hasUserInfo: true
                })
                app.userInfo = res.userInfo // 考虑到很多页面会使用用户信息，添加到全局实例中
                wx.setStorageSync('userInfo', res.userInfo) // 将用户信息保存到本地存储中
          }
        })
    },
```

### 添加收藏到本地缓存
当我们到详情页点击收藏了，关于页面需要展示出来，我们可以使用小程序里的缓存，把数据存到本地缓存中，这样就可以实现多页面之间数据的共享
先到`about`页面，定义一个收藏电影信息的属性，考虑到每个电影有个唯一`id`，方便删除操作，这里定义为对象比较合适
```js
    /**
     * 页面的初始数据
     */
    data: {
        userInfo: null, // 存储局部用户信息
        favorites: {}, // 存储收藏的电影信息
    },
```

进入`about.wxml`展示页面，直接遍历这个收藏电影对象，如果为空就显示不会收藏电影，从而显示下面暂无收藏，当有电影时得让暂无收藏消失，这时可以使用一个变量，最开始默认是没有收藏的，设置为`true`，让它显示暂无收藏【这个开关的控制阀门在哪后面再处理】
```js
    data: {
        userInfo: null, // 存储局部用户信息
        favorites: {}, // 存储收藏的电影信息
        showNoFavorite: true, // 是否显示暂无收藏
    },
```
详情页面点击收藏有个前提条件，必须是登陆了的用户才能点击收藏，进入`detail.wxml`，找到收藏按钮，给它绑定一个事件`addFavorite`，进入`detail.js`定义这样一个方法
```js
    // 添加收藏
    addFavorite() {
        // 如果用户没有登陆，给一个提示，让用户先登陆了才能收藏
        let userInfo = wx.getStorageSync('userInfo')
        // 判断用户是否登陆
        if (!userInfo) {
            wx.showModal({
              title: '提示',
              content: '请先登陆'
            })
            return // 终止掉函数
        }
        // 已经登陆，添加电影到本地缓存，如果取不到【首次】就是空字符串，而我们favorite设计的是对象，处理一下即可
        // 获取本地缓存中收藏的电影
        var favorites = wx.getStorageSync('favorites') || {}
        // 判断是否已收藏
        if (favorites[this.data.filmId]) {
            wx.showToast({
              title: '已收藏',
              image: '/imgs/error.png'
            })
            return
        }
        // 添加电影到本地缓存
        favorites[this.data.filmId] = this.data.film
        // 存到缓存中【下方控制台Storage可以查看有没有存进去】
        wx.setStorageSync('favorites', favorites)
        // 收藏成功提示
        wx.showToast({
          title: '收藏成功',
          image: '/imgs/success.png'
        })
    },
```

### 展示本地缓存中收藏的电影
> 进入`about.js`文件中，这里考虑一个问题，是在`onload`中获取本地缓存中收藏的电影吗？
首先我们得知道`onload`只执行一次，这个所谓得一次会造成，当我们从首页进入关于页面这个`onload`执行了一次，但是这个时候我又回到详情页收藏了一部电影，本地缓存数据变了，再进关于页面你这个`onload`不会再执行了，那你刚刚新收藏的电影也就无法获取展示出来。
为了解决这个问题，我们应该使用`onshow`这个生命周期，从其它页面切换到这个页面它都会执行
```js
    onShow: function () {
        // 从本地缓存中把收藏电影取出来
        let favorites = wx.getStorageSync('favorites')
        // 要在页面上使用，需要放到数据仓库中
        this.setData({
            favorites,
            showNoFavorite: Object.keys(favorites) == 0 // 当收藏为空时显示【需要拿到最新的收藏电影来做这个判断，所以开关阀门在这里】
        })
    },
```

页面上展示，由于遍历`favorites`对象，需要把每个值也就是单个电影对象往`film-item`传，直接传递`item`即可
```html
    <!-- 我的收藏 start -->
    <view class="favorite">
        <view class="favorite-title">我的收藏</view>
        <view class="favorite-list">
            <view class="favorite-item" wx:for="{{ favorites }}" wx:key="index">
                <film-item film="{{ item }}"></film-item>
                <button class="delete" size="mini" plain type="warn">删除</button>
            </view>
        </view>
        <view wx:if="{{ showNoFavorite }}" class="favorite-no">~~暂无收藏~~</view>
    </view>
    <!-- 我的收藏 end -->
```

最后一个问题就是接口问题，图片不显示，由于传递给`film-item`组件，不好到组件中修改，最好存储到本地换成之前替换上图片，进入`detail.js`文件中，把下面代码加到在给`favorites`对象添加属性和属性值之前
```js
        // 添加电影到本地缓存
        // 由于图片原因，不好到film-item组件中修改，所以到这里修改图片路径【detail和home接口问题，这里需要把图片给它换成有效的图片】
        this.data.film.cover.url = this.data.film.cover_url
```

### 删除收藏电影
进入`about.wxml`页面给删除按钮绑定事件`deleteFavorite`，但是点击对应的电影我们应该传个参数过去，这样才能对应删除哪个收藏电影，由于遍历的是对象，`index`不就是电影对象的`key`即`id`吗，`item`就是单个电影对象，传递方式采用`data-`即自定义属性，取得话直接用事件对象
```html
    <button class="delete" size="mini" plain type="warn" bindtap="deleteFavorite" data-id="{{ index }}">删除</button>
```

接着进入`about.js`，定义这个删除函数，同时传递事件对象，取出电影`id`，接着就是关于页面数据仓库的删除和本地缓存的删除
```js
    deleteFavorite(e) { // 删除收藏电影
        // console.log(e); // 打印一下事件对象，里面有个currentTarget属性接着还有个dataset属性里面存储着id
        // console.log(e.currentTarget.dataset.id); // 成功打印id
        let id = e.currentTarget.dataset.id // 获取事件触发时传递的参数

        // 先从数据仓库中删除，delete之后是要重新赋值数据仓库的，不然页面上不会改变
        delete this.data.favorites[id]
        this.setData({
            favorites: this.data.favorites,
            showNoFavorite: Object.keys(this.data.favorites).length == 0 // 注意这里是this.data.favorites，它是刚刚delete删除了的最新的收藏数据，如果长度为0说明删完了
        })

        // 从本地缓存中删除
        wx.setStorageSync('favorites', this.data.favorites) // 直接用上面已经删除的faborites
    },
```

